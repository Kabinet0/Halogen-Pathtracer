#pragma kernel HalogenCompute
#pragma use_dxc

// TODO:
// [X] Absorbtion does something to opaque objects for some reason? [KIND OF]
// [X] Speckles on green panel in cornel box (Importance sampling bug)
// [X] Owen scrambles sobol sampling
// [-] Optimise sobol sampling
// [-] Invert priority for dielectrics to make more sense
// [-] Better importance sampling controls
// [-] Basic instancing support
// [X] Solve BVH Splitting errors [Turns out they weren't actual errors]
// [-] Add SAH to BVH
// [-] TLAS
// [-] Punctual Lights
// [-] Multiple Importance Sampling
// [-] More debug views (roughness, whatever)


/* Constants */
#define QUESTIONABLE_IMPORTANCE_SAMPLING 1
#define QUESTIONABLE_IMPORTANCE_SAMPLING_RANGE 8.0f // deeply jank

static const float PI = radians(180);
static const float epsilon = 0.00001f;
static const float empty_medium_IOR = 1;

/* Input Data */
float4x4 CamLocalToWorldMatrix;

// Packing these more efficiently would be easy, but I don't want to
float4 ScreenParameters; // x: x resolution
                         // y: y resolution
                         // z:
                         // w:

float4 ViewParameters; // x: w/2 for clip plane
                       // y: h/2 for clip plane
                       // z: near clip plane distance
                       // w: far clip plane distance

float4 CameraParameters; // x: Camera X
                         // y: Camera Y
                         // z: Camera Z
                         // w:

RWTexture2D<float4> Output;
RWTexture2D<float4> OutputSecondBounce;

int UseEnvironmentCubemap;
TextureCube EnvironmentCubemap;
SamplerState EnviornmentCubemapSampler_trilinear_repeat;

uint SamplesPerPixel;
uint MaxBounces;
int FrameCount;

uint HalogenDebugMode;
uint TriangleDebugDisplayRange;
uint BoxDebugDisplayRange;

int DefaultHDRIMipLevel;

float focalPlaneDistance;
float focalConeAngle;

/* Struct definitions */
struct ParticipatingRayMedium
{
    float indexOfRefraction;
    float3 absorption;
    int priority;
    uint materialID; // duplicated here so there's something to id mediums with in the medium list
};

// ugh why can't I make struct constructors D:
ParticipatingRayMedium get_empty_medium() {
    ParticipatingRayMedium empty_medium;
    empty_medium.indexOfRefraction = 1;
    empty_medium.materialID = -1;
    empty_medium.priority = 1.#INF;
    empty_medium.absorption = float3(0,0,0);

    return empty_medium;
}


struct HalogenMaterial
{
    uint materialID;
 
    float4 albedo;
    float4 specularAlbedo;
    float metallic;
    float roughness;
    float4 emissive;

    /* Describes medium inside material (Meshes in Halogen need to be manifold) */
    ParticipatingRayMedium internalMedium;
};

struct Sphere
{
    float3 center;
    float radius;
    uint materialIndex;
    float3 boundingCornerA;
    float3 boundingCornerB;
};

struct Mesh
{
    uint triangleBufferOffset;
    uint accelerationBufferOffset;
    float3 boundingCornerA;
    float3 boundingCornerB;
    uint materialIndex;
    float4x4 worldToLocal;
    float4x4 localToWorld;
    // float4x4 normalMatrix; // if desired
};

struct BVHEntry
{
    uint indexA;
    uint triangleCount;
    float3 boundingCornerA;
    float3 boundingCornerB;
};

struct Triangle
{
    float3 v0, v1, v2;
    float3 n0, n1, n2;
};

struct Ray
{
    float3 origin;
    float3 dir;
};


struct MeshHitInfo
{
    uint objectID;
};

/*
 * Data describing a ray hitting a surface, as well the surface being hit
 * Input data for BSDF
*/
struct RayHit
{
    float rayT;
    half orientation;
    float3 pos; 
    float3 normal;
    HalogenMaterial material;
    MeshHitInfo meshData;
};

/*
 * Data describing a ray intersecting a triangle
 * Used to build a RayHit once intersection testing is finished
*/
struct RayTriangleIntersection
{
    float rayT;
    float3 baryCoords;
    uint2 triangleIndex; // x: mesh index
                         // y: triangle offset index
    half orientation;
};

/* Data buffers */
StructuredBuffer<Triangle> TriangleBuffer;
StructuredBuffer<BVHEntry> BLASBuffer;
StructuredBuffer<HalogenMaterial> MaterialList;
StructuredBuffer<Sphere> SphereList;
StructuredBuffer<Mesh> MeshList;
float4 BufferCounts; // x: Spheres, y: MeshData

/* Interface tracking for nested dielectrics */
static ParticipatingRayMedium participatingMediumStack[8];
static int mediumStackPointer = 0;

/* Debugging Related Variables */
static int TriangleTests = 0;
static int AABBTests = 0;


/*
 * 2D [4][32] Array mapped to a 1D array 
 * Dimensions past four are padded from this table
*/
static const uint sobol_table[128] = {
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,

    0x80000000, 0xc0000000, 0xa0000000, 0xf0000000,
    0x88000000, 0xcc000000, 0xaa000000, 0xff000000,
    0x80800000, 0xc0c00000, 0xa0a00000, 0xf0f00000,
    0x88880000, 0xcccc0000, 0xaaaa0000, 0xffff0000,
    0x80008000, 0xc000c000, 0xa000a000, 0xf000f000,
    0x88008800, 0xcc00cc00, 0xaa00aa00, 0xff00ff00,
    0x80808080, 0xc0c0c0c0, 0xa0a0a0a0, 0xf0f0f0f0,
    0x88888888, 0xcccccccc, 0xaaaaaaaa, 0xffffffff,

    0x80000000, 0xc0000000, 0x60000000, 0x90000000,
    0xe8000000, 0x5c000000, 0x8e000000, 0xc5000000,
    0x68800000, 0x9cc00000, 0xee600000, 0x55900000,
    0x80680000, 0xc09c0000, 0x60ee0000, 0x90550000,
    0xe8808000, 0x5cc0c000, 0x8e606000, 0xc5909000,
    0x6868e800, 0x9c9c5c00, 0xeeee8e00, 0x5555c500,
    0x8000e880, 0xc0005cc0, 0x60008e60, 0x9000c590,
    0xe8006868, 0x5c009c9c, 0x8e00eeee, 0xc5005555,
 
    0x80000000, 0xc0000000, 0x20000000, 0x50000000,
    0xf8000000, 0x74000000, 0xa2000000, 0x93000000,
    0xd8800000, 0x25400000, 0x59e00000, 0xe6d00000,
    0x78080000, 0xb40c0000, 0x82020000, 0xc3050000,
    0x208f8000, 0x51474000, 0xfbea2000, 0x75d93000,
    0xa0858800, 0x914e5400, 0xdbe79e00, 0x25db6d00,
    0x58800080, 0xe54000c0, 0x79e00020, 0xb6d00050,
    0x800800f8, 0xc00c0074, 0x200200a2, 0x50050093
};

/*
 * Helper function to index the 1D sobol direction table as 2D 
*/
uint sobol_table_get(uint dim, uint bit) {
    return sobol_table[(dim * 32) + bit];
}

/*
 * Dimension constants for the various random events in a frame
 * TODO: Make sure combining use of 1D and 2D samples can't repeat sequences
*/

/* Used for setting up the ray's starting conditions */
static const uint FOCAL_DISC_RANDOM_ID = 0;
static const uint RAY_JITTER_RANDOM_ID = 1;

/* Used for both rough reflection and refraction technically, depending on which event occurs */
static const uint ROUGH_REFLECTION_RANDOM_ID = 2;

/* Used for 2D sample that encompasses both doing refraction and specular scattering */
static const uint MATERIAL_BRDF_PROPERTY_RANDOM_ID = 3; 

/* What the random dimension offset is incremented by each bounce */
static const uint BOUNCE_RANDOM_INCREMENT = 4; 

/* RNG State */
static uint SobolDimensionOffset = 0;
static uint pixelID; 

/* State for simple PRNG */
static uint hashState;

/* 
 * https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
 * PRNG variant of PCG hash
*/
uint u32_hash_stateful(uint value = hashState) {
    uint state = value * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    hashState = state;

    return (word >> 22u) ^ word;
}

/*
 * Literal Sebastian Lague theft: https://www.youtube.com/watch?v=Qz0KTGYJtUk&t=679s
 * Also discovered (independantly I swear) from on https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/ 
 * 
 * The standard PCG hash
*/
uint u32_hash(uint value) {
    uint state = value * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;

    return (word >> 22u) ^ word;;
}

/*  
 * From Practical Hash-based Owen Scrambling (https://jcgt.org/published/0009/04/01/)
 * Probably good enough to smash two numbers together
 * Swap for something else later maybe
*/
uint hash_combine(uint seed, uint v) {
    return seed ^ (v + (seed << 6) + (seed >> 2));
}

/*
 * Thanks to https://psychopath.io/post/2021_01_30_building_a_better_lk_hash
 * as well as PBRT
 * used for both scrambling and shuffling the sobol sample sequence
*/ 
uint owen_scramble(uint value, uint seed) {
    // Randomize inital seed value
    // replace with u32 hash
    // uint seed = u32_hash();

    uint x = reversebits(value);

    // // Original Laine-Karras hash.
    // x = x.wrapping_add(seed);
    // x ^= x.wrapping_mul(0x6c50b47c);
    // x ^= x.wrapping_mul(0xb82f1e52);
    // x ^= x.wrapping_mul(0xc7afe638);
    // x ^= x.wrapping_mul(0x8d22f6e6);

    x ^= x * 0x3d20adea;
    x += seed;
    x *= (seed >> 16) | 1;
    x ^= x * 0x05526c56;
    x ^= x * 0x53a22864;

    return reversebits(x);
}

// unknown source 1d sobol probably
// uint sobol(uint index) {
//     uint p = 0;
//     uint d = 0x80000000;

//     for (; index != 0; index >>= 1) {
//         if ((index & 1) != 0) {
//             p ^= d;
//         }
//         d >>= 1;
//     }

//     return p;
// }

uint sobol1d(uint index, uint dim) {
    uint X = 0;
    for (int bit = 0; bit < 32; bit++) {
      int mask = (index >> bit) & 1;
      X ^= mask * sobol_table_get(dim, bit);
    }
    return X;
}

uint2 sobol2d(uint index) {
    return uint2(sobol1d(index, 0), sobol1d(index, 1));
}

uint4 sobol4d(uint index) { 
    return uint4(sobol1d(index, 0), sobol1d(index, 1), sobol1d(index, 2), sobol1d(index, 3));
}


/*
 * Gets an element of a low discrepancy sample sequence
 * Seed shuffles and effectively pads dimensions
 * dimension is fed into seed to make function easier to use
 * seed should be pixel index
 * index is sample index
*/
uint u32_owen_scrambled_sobol(uint index, uint dimension, uint seed) {
    seed ^= u32_hash(dimension);

    uint output = owen_scramble(sobol1d(index, 0), u32_hash(seed)); // scrambling adds randomization 

    return output;
}

/*
 * Gets a 2D element of a low discrepancy sample sequence
 * See the 1D variant for more information
*/
uint2 u32_2d_owen_scrambled_sobol(uint index, uint dimension, uint seed) {
    seed ^= u32_hash(dimension);

    // confusingly enough, owen_scramble() is used for both shuffling and scrambling
    uint shuffledIndex = owen_scramble(index, seed); // shuffles index to decorrelate between dimensions
    uint2 sobolPoints = sobol2d(shuffledIndex);

    uint2 output;
    // scrambling adds randomization 
    output.x = owen_scramble(sobolPoints.x, hash_combine(seed, 0));
    output.y = owen_scramble(sobolPoints.y, hash_combine(seed, 1));

    return output;
}


/*
 * Gets a 4D element of a low discrepancy sample sequence
 * See the 1D variant for more information
*/
uint4 u32_4d_owen_scrambled_sobol(uint index, uint dimension, uint seed) {
    seed ^= u32_hash(dimension);

    // confusingly enough, owen_scramble() is used for both shuffling and scrambling
    uint shuffledIndex = owen_scramble(index, seed); // shuffles index to decorrelate between dimensions
    uint4 sobolPoints = sobol4d(shuffledIndex);

    uint4 output;
    // scrambling adds randomization 
    output.x = owen_scramble(sobolPoints.x, hash_combine(seed, 0));
    output.y = owen_scramble(sobolPoints.y, hash_combine(seed, 1));
    output.z = owen_scramble(sobolPoints.z, hash_combine(seed, 2));
    output.w = owen_scramble(sobolPoints.w, hash_combine(seed, 3));

    return output;
}
 
float float_owen_scrambled_sobol(uint index, uint dimensionID, uint seed) {
    return ((float)u32_owen_scrambled_sobol(index, SobolDimensionOffset + dimensionID, seed)) / 4294967296.0f;
}

float2 float2_owen_scrambled_sobol(uint index, uint dimensionID, uint seed) {
    return ((float2)u32_2d_owen_scrambled_sobol(index, SobolDimensionOffset + dimensionID, seed)) / 4294967296.0f;
}

float4 float4_owen_scrambled_sobol(uint index, uint dimensionID, uint seed) {
    return ((float4)u32_4d_owen_scrambled_sobol(index, SobolDimensionOffset + dimensionID, seed)) / 4294967296.0f;
}

/*
 * Wraps u32_hash_stateful, giving a very simple but decent PRNG sequence
 * Returns floats between 0-1
*/
float random_value()
{
    return (float) u32_hash_stateful() / 4294967296.0f;
}


/*
 * Gets a random unit vector well distributed within a sphere
*/
float3 get_random_unit_vector(float2 randomData)
{
    float2 uv = randomData;
    float theta = uv.x * 2.0 * PI;
    float phi = acos(2.0 * uv.y - 1.0);
    float r = 1;
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float sinPhi = sin(phi);
    float cosPhi = cos(phi);
    float x = r * sinPhi * cosTheta;
    float y = r * sinPhi * sinTheta;
    float z = r * cosPhi;
    float3 randomVector = float3(x, y, z);
    
    return randomVector;
}

/*
 * Gets a random point vector well distributed within 2D circle
*/
float2 get_random_point_circle(float radius, float2 randomData)
{
    float theta = radians(randomData.x * 360);
    float distAlongRadius = randomData.y;
    return float2(cos(theta) * radius * distAlongRadius, sin(theta) * radius * distAlongRadius);
}



float3 sample_sky(Ray ray, int level = DefaultHDRIMipLevel)
{
    // float v = 0.5f * (ray.dir.y + 1.0f);
    // return lerp(float3(0.1f, 0.1f, 0.1f), float3(0.5f, 0.7f, 1.0f), v) * 0.7f;
    if (UseEnvironmentCubemap > 0) {
        return EnvironmentCubemap.SampleLevel(EnviornmentCubemapSampler_trilinear_repeat, ray.dir, level);
    }
    return float3(0.0f, 0.0f, 0.0f);
}

/*
 * Ensures direction normalization after being converted 
*/
Ray convert_ray_space(in Ray ray, float4x4 mat)
{
    Ray outputRay;
    outputRay.origin = (float3) mul(mat, float4(ray.origin, 1.0f));
    outputRay.dir = normalize((float3) mul(mat, float4(ray.dir, 0.0f)));
    
    return outputRay;
}

/*
 * Explicitly does not normalize direction
*/
Ray convert_ray_space_unf(in Ray ray, float4x4 mat)
{
    Ray outputRay;
    outputRay.origin = (float3) mul(mat, float4(ray.origin, 1.0f));
    outputRay.dir = (float3) mul(mat, float4(ray.dir, 0.0f));
    
    return outputRay;
}

/*
 * Takes a normal (might be backface) and flips if needed based on ray
*/
void determine_frontface(inout RayHit hit, float3 dir) 
{
    bool frontFace = dot(dir, hit.normal) < 0.0;
    if (!frontFace) {
        hit.normal = -hit.normal;
    }
}

/*
 * ray_preInv expects a pre inverted direction aka. 1/dir, which is precomputed and baked into the ray struct 
*/
float ray_AABB_test(float3 cornerA, float3 cornerB, in Ray ray_preInv)
{
    float3 t1 = (cornerA - ray_preInv.origin) * ray_preInv.dir;
    float3 t2 = (cornerB - ray_preInv.origin) * ray_preInv.dir;
    
    float tMin = min(t1.x, t2.x);
    float tMax = max(t1.x, t2.x);
    
    tMin = max(tMin, min(t1.y, t2.y));
    tMax = min(tMax, max(t1.y, t2.y));
    
    tMin = max(tMin, min(t1.z, t2.z));
    tMax = min(tMax, max(t1.z, t2.z));
    
    return tMax > max(0, tMin) ? tMin : 1.#INF;
}



// todo math here can be optimised, division by a can be axed
// can't be bothered to do it now though
// on second thought this whole function is a mess that needs some tlc
RayHit sphere_intersection(Ray ray, Sphere sphere)
{
    float3 shiftedRayOrigin = ray.origin - sphere.center;
    
    // coefficients for quadratic equation
    //float a = dot(ray.dir, ray.dir); // This should be 1, like, always?
    float a = 1; // TWO WEEKS LATER: BE SURE DIRECTION IS NORMALIZED DUMMY  <-- This mistake cost me at least three days
    
    float b = 2.0 * dot(shiftedRayOrigin, ray.dir);
    float c = dot(shiftedRayOrigin, shiftedRayOrigin) - sphere.radius * sphere.radius;
    
    float discriminant = b * b - 4*a*c;
    
    RayHit rayhit = (RayHit)0;
    rayhit.rayT = 1.#INF;
    
    if (discriminant >= 0.0f)
    {
        float hitDistance = (-b - sqrt(discriminant)) / (2.0 * a);
        rayhit.orientation = 1;

        // there has to be a better way to do this, right???
        if (hitDistance < 0.0f)
        {
            hitDistance = (-b + sqrt(discriminant)) / (2.0 * a);
            rayhit.orientation = -1;
        }

        rayhit.rayT = hitDistance;
        rayhit.pos = ray.origin + ray.dir * hitDistance;
        // rayhit.orientation = (distance(rayhit.pos, sphere.center) + epsilon - sphere.radius) > 0 ? 1 : -1; // yeah sure whatever
        rayhit.normal = normalize(rayhit.pos - sphere.center) * rayhit.orientation; // outward normal
        rayhit.material = MaterialList[sphere.materialIndex];
    }
    
    
    return rayhit;
}


// Includes weird aah trick to get correct distance to ray
RayTriangleIntersection triangle_intersection_doublesided(Ray ray, Triangle tri)
{
    RayTriangleIntersection rayIntersection = (RayTriangleIntersection)0;
    rayIntersection.rayT = 1.#INF;
    
    float3 v0v1 = tri.v1 - tri.v0;
    float3 v0v2 = tri.v2 - tri.v0;
    float3 normal = cross(v0v1, v0v2);
    
    // Determinant
    float3 cross_dir_v0v2 = cross(ray.dir, v0v2);
    float determinant = dot(cross_dir_v0v2, v0v1);
    
    // Ray is parallel to triangle plane
    if (abs(determinant) < 0.00000001f)
    {
        return rayIntersection;
    }
    float inv_determinant = 1 / determinant;
    
    float3 OriginV0 = ray.origin - tri.v0;
    
    // Barycentric U
    float U = dot(OriginV0, cross_dir_v0v2) * inv_determinant;
    if (U < 0.0 || U > 1.0)
    {
        return rayIntersection;
    }
    
    // Barycentric V
    float3 cross_OriginV0_v0v1 = cross(OriginV0, v0v1);
    float V = dot(ray.dir, cross_OriginV0_v0v1) * inv_determinant;
    if (V < 0.0 || U + V > 1.0)
    {
        return rayIntersection;
    }
    
    float rayT = dot(v0v2, cross_OriginV0_v0v1) * inv_determinant;
    if (rayT > 0)
    {
        rayIntersection.baryCoords = float3(U, V, 1 - U - V);
        
        rayIntersection.rayT = rayT;
        rayIntersection.orientation = sign(determinant);
    }

    // Fill in triangle index outside of function
    return rayIntersection;
}

void get_ray_scene_intersection_sphere(in Ray ray, inout RayHit closestHit)
{
    float closestDistance = closestHit.rayT;
    float hitDistanceEpsilon = 0.0001f;
    
    Ray ray_preInv = ray; // Pre invert and cache result for faster intersecion testing
    ray_preInv.dir = 1 / ray_preInv.dir;
    for (int i = 0; i < (int)BufferCounts.x; i++) 
    {
        if (ray_AABB_test(SphereList[i].boundingCornerA, SphereList[i].boundingCornerB, ray_preInv) < ViewParameters.w) // hit must be closer than far clip plane
        {
            RayHit hit = sphere_intersection(ray, SphereList[i]);
            if (hit.rayT < closestDistance && hit.rayT > hitDistanceEpsilon)
            {
                closestHit = hit;
                closestDistance = hit.rayT;
            }
        }
    }
}

void get_ray_scene_intersection_mesh(in Ray ray, inout RayHit closestHit)
{
    RayTriangleIntersection closestIntersection;
    closestIntersection.rayT = closestHit.rayT;

    float hitDistanceEpsilon = 0.0001f;
    
    // Test for ray intersection
    for (int i = 0; i < (int)BufferCounts.y; i++)
    {
        Mesh meshData = MeshList[i];
       
        // Intentionally do not normalize direction to avoid converting distance back to world space
        // as documented here: https://graphicscompendium.com/raytracing/12-transformations
        Ray localRay = convert_ray_space_unf(ray, meshData.worldToLocal);
        // Pre invert and cache local ray for BVH AABB testing, normalize direction to not mess with intersection test math
        Ray localRay_preInv = localRay;
        localRay_preInv.dir = 1 / (localRay_preInv.dir);

        int NodeStack[32];
        int stackPointer = 0;

        // Push first node to stack, can skip first node once TLAS exists
        NodeStack[stackPointer++] = meshData.accelerationBufferOffset;

        while (stackPointer > 0) {
            // pop out current node being processed
            BVHEntry currentNode = BLASBuffer[NodeStack[--stackPointer]];

            if (currentNode.triangleCount > 0) { // this node is a leaf node
                // Intersect through triangles in leaf node
                for (uint tri = 0; tri < currentNode.triangleCount; tri++)
                {
                    RayTriangleIntersection intersection = triangle_intersection_doublesided(localRay, TriangleBuffer[tri + meshData.triangleBufferOffset + currentNode.indexA]);
                    TriangleTests++;

                    // Convert distance to world space
                    //intersection.rayT = length((float3) mul(meshData.localToWorld, float4(intersection.rayT * localRay.dir, 0.0f)));
                    if (intersection.rayT > hitDistanceEpsilon && intersection.rayT < closestIntersection.rayT)
                    {
                        closestIntersection = intersection;
                        closestIntersection.triangleIndex = uint2(i, tri + currentNode.indexA); // consider cleaner way?
                    }
                }
            } else { // this node is a hierarchy node
                BVHEntry childNodeA = BLASBuffer[meshData.accelerationBufferOffset + currentNode.indexA];
                BVHEntry childNodeB = BLASBuffer[meshData.accelerationBufferOffset + currentNode.indexA + 1];

                float distanceA = ray_AABB_test(childNodeA.boundingCornerA, childNodeA.boundingCornerB, localRay_preInv);
                float distanceB = ray_AABB_test(childNodeB.boundingCornerA, childNodeB.boundingCornerB, localRay_preInv);
                AABBTests += 2;

                if (distanceB < distanceA){
                    if (distanceA < closestIntersection.rayT){
                        NodeStack[stackPointer++] = meshData.accelerationBufferOffset + currentNode.indexA;
                    }
                    if (distanceB < closestIntersection.rayT){
                        NodeStack[stackPointer++] = meshData.accelerationBufferOffset + currentNode.indexA + 1;
                    }
                } else {
                    if (distanceB < closestIntersection.rayT){
                        NodeStack[stackPointer++] = meshData.accelerationBufferOffset + currentNode.indexA + 1;
                    }
                    if (distanceA < closestIntersection.rayT){
                        NodeStack[stackPointer++] = meshData.accelerationBufferOffset + currentNode.indexA;
                    }
                }
            }
        }
        
    }

    // Verify that triangle intersection is valid and closer than any previous intersection
    // If so, build new RayHit 
    if (closestIntersection.rayT < (closestHit.rayT - hitDistanceEpsilon) && closestIntersection.rayT < ViewParameters.w){
        Mesh meshData = MeshList[closestIntersection.triangleIndex.x];
        Triangle tri = TriangleBuffer[meshData.triangleBufferOffset + closestIntersection.triangleIndex.y];
        
        closestHit.rayT = closestIntersection.rayT;
        
        closestHit.material = MaterialList[meshData.materialIndex];

        closestHit.orientation = closestIntersection.orientation;

        // For reasons unknown to me barycentric coordinates are layed out relative to verticies in the pattern wuv as opposed to uvw, no I don't know why, just roll with it
        closestHit.normal = (tri.n0 + (tri.n1 - tri.n0) * closestIntersection.baryCoords.x + (tri.n2 - tri.n0) * closestIntersection.baryCoords.y); // Works a bit like the lerp function but with three values
        //hit.normal = tri.n0 * closestIntersection.baryCoords.z + tri.n1 * closestIntersection.baryCoords.x + tri.n2 * closestIntersection.baryCoords.y; 
        closestHit.normal = closestHit.normal * closestIntersection.orientation; // flip normal to make doublesided if hit backface
        // multiply by inverse transpose of matrix to get correct normal scaling https://forum.unity.com/threads/world-space-normal.58810/
        closestHit.normal = normalize(mul(float4(closestHit.normal, 0.0), meshData.worldToLocal).xyz); 
        //closestIntersection.normal = normalize((float3) mul(meshData.localToWorld, float4(closestIntersection.normal, 0.0f)));

        closestHit.pos = ray.origin + (ray.dir * closestIntersection.rayT); // add epsilon to position later
    }
}

RayHit get_ray_intersection(in Ray ray)
{ 
    RayHit closestHit;
    closestHit.rayT = 1.#INF; // Start with infinitely far away intersection
    
    get_ray_scene_intersection_sphere(ray, closestHit);
            
    get_ray_scene_intersection_mesh(ray, closestHit);

    //closestHit.material.albedo = float4(closestHit.orientation, 0, 0, 0.0f);
    return closestHit;
}

/* 
 * Combines a random vector with a normal using a Lambertian distribution 
 * Additionally performs checks (one check lol) to ensure validitiy
*/
float3 lambertain_scatter(in float3 normal, in float3 random_vector)
{
    float3 scatterPointLambertain = random_vector + normal;
    if (length(scatterPointLambertain) < 1e-8) { // Catch tiny ray distance & rounding errors
        scatterPointLambertain = normal;
    }

    // Not normalizing appears to do nothing here
    // I don't know why        
    return normalize(scatterPointLambertain);
}

/*
 * Note: apparently this is the same as the default hlsl reflect() function
*/
float3 specular_scatter(in float3 incident, in float3 normal)
{
    return incident - 2 * dot(incident, normal) * normal;
}

float3 schlick_approximation(float3 specularColor, float3 incidentDirection, float3 halfwayVector)
{
    return specularColor + (1 - specularColor) * pow((1 - (incidentDirection * halfwayVector)), 5);
}

/*
 * Calculates influence of fresnel on specular value
*/
float schlick_adjusted_specular(float n1, float n2, float3 normal, float3 incident, float minSpecular, float maxSpecular)
{
    // Schlick aproximation
    float r0 = (n1-n2) / (n1+n2);
    r0 *= r0;
    float cosX = -dot(normal, incident);
    if (n1 > n2)
    {
        float n = n1/n2;
        float sinT2 = n*n*(1.0-cosX*cosX);

        // Total internal reflection
        if (sinT2 > 1.0)
            return maxSpecular;
        cosX = sqrt(1.0-sinT2);
    }
    float x = 1.0-cosX;
    float ret = r0+(1.0-r0)*x*x*x*x*x;

    // adjust reflect multiplier for object reflectivity
    return lerp(minSpecular, maxSpecular, ret);
}

/* 
 * Trowbridge-Reitz Distribution 
 * Squares roughness to improve perceptual linearity
 * Entirely unimplemented unused remenant of trying to implement PBRT's microfacet BRDF
 * Mostly a reminder for me to do this later
*/
float3 microfacet_normal_distribution(float3 halfwayVector, float roughness)
{
    //float tan2Theta = tan2
    return float3(1, 1, 1);
}

/*
 * Like the HLSL refract() function but with total internal reflection handling (At least I'm pretty sure HLSL's doesn't have it?)
*/
float3 refract(float3 incident, float3 normal, float n1, float n2, inout bool totalInternalReflection) {
    float cos_theta = min(dot(-incident, normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);
     
    float n1_over_n2 = n1 / n2;

    if (n1_over_n2 * sin_theta > 1.0) {
        // handle total internal reflection
        totalInternalReflection = true;
        return specular_scatter(incident, normal);
    } else {
        float3 refracted_perp =  n1_over_n2 * (incident + cos_theta*normal);
        float3 refracted_parallel = -sqrt(abs(1.0 - (length(refracted_perp) * length(refracted_perp)))) * normal;
        return refracted_perp + refracted_parallel;
    }
}

/* 
 * Inserts a medium to the medium stack, sorts stack for basically free reading of the top element at any given moment
 * I don't know if this is the most efficient way to do it, and I don't care
 * Full of edgecase handling, and remarkably hard to read
 * 
 * TODO: Handle too many intersections, somehow
 * TODO: 0 is the highest priority right now, invert that
*/
void add_to_medium_stack(in ParticipatingRayMedium medium) {
    // note:
    // mediumStackPointer refers to current size of stack, and ponints to where to put next element

    if (mediumStackPointer == 0) {
        // stack is empty
        participatingMediumStack[mediumStackPointer++] = medium;
    } else {
        // not empty, sort
        int insertionIndex = mediumStackPointer;
        if (medium.priority > participatingMediumStack[mediumStackPointer - 1].priority) {

            for (int i = mediumStackPointer - 1; i >= 0; i--) {
                if (medium.priority < participatingMediumStack[i].priority) {
                    insertionIndex = i + 1;
                    break;
                }
            }

            // if not found an insertion index yet (needs insertion at bottom of stack)
            if (insertionIndex == mediumStackPointer) {
                insertionIndex = 0;
            }
        }

        if (insertionIndex != mediumStackPointer) {
            // other elements need shifting
            for (int i = mediumStackPointer - 1; i >= insertionIndex; i--) {
                participatingMediumStack[i + 1] = participatingMediumStack[i];
            }

            mediumStackPointer++;

            // insert element at newly cleared index
            participatingMediumStack[insertionIndex] = medium;
        } else {
            // it's at the end of the list anyways
            participatingMediumStack[mediumStackPointer++] = medium;
        }
    }
}

/*
 * Attempt removing a medium from the interface tracking stack by ID
*/
void pop_from_medium_stack(uint materialID) {
    for (int i = 0; i < mediumStackPointer; i++) {
        if (participatingMediumStack[i].materialID == materialID) {
            // found right element to remove
            // no real concept of null in gpu programming so just shift all the other stack elements over and reduce the pointer
            for (int k = i + 1; k < mediumStackPointer; k++) {
                participatingMediumStack[k - 1] = participatingMediumStack[k]; 
            }

            mediumStackPointer--;

            return;
        }
    }
    // If the medium isn't found just cope about it I guess
}

/*
 * Gets the top medium currently affecting the ray. The list is always sorted, so retreival is really simple. 
*/
ParticipatingRayMedium get_top_ray_medium() {
    if (mediumStackPointer > 0) {
        // stack not empty, get highest priority element
        return participatingMediumStack[mediumStackPointer - 1];
    } else {
        return get_empty_medium(); // kinda sucks also does this take vgpr or something
    }
}

bool determine_true_medium_hit(int priority) {
    // in case list is empty
    if (mediumStackPointer == 0) {
        return true;
    }
    if (priority <= participatingMediumStack[mediumStackPointer - 1].priority) {
        return true;
    }
    return false;
}

/*
 * Kind of jank, loosely physically based BRDF
 * really shouldn't conserve energy, but I've never checked, so who knows
 * Todo: replace all of this with a proper microfacet model from PBRT
*/
float3 material_BRDF(inout Ray ray, in RayHit hit, ParticipatingRayMedium currentMedium, ParticipatingRayMedium hitMedium, inout bool didRefract)
{
    float3 attenuation = float3(1, 1, 1);

    ray.origin = hit.pos;


    float2 randomData = float2_owen_scrambled_sobol(FrameCount, ROUGH_REFLECTION_RANDOM_ID, pixelID);
    float2 propertyRandom = float2_owen_scrambled_sobol(FrameCount, MATERIAL_BRDF_PROPERTY_RANDOM_ID, pixelID);

    float3 roughReflectionRandom = get_random_unit_vector(randomData.xy);
    bool do_refraction = propertyRandom.x > hit.material.albedo.w;
    float specular_scatter_random = propertyRandom.y;

    if (!do_refraction) {
        //// Regular bounce ////
        attenuation = hit.material.albedo.rgb;
        float3 diffuseRayDir = lambertain_scatter(hit.normal, roughReflectionRandom);

        bool do_specular_scatter = specular_scatter_random < ((hit.material.metallic > 0) ? schlick_adjusted_specular(currentMedium.indexOfRefraction, hitMedium.indexOfRefraction, hit.normal, ray.dir,  hit.material.metallic, 1) : hit.material.metallic);
        if (do_specular_scatter)
        {
            float3 specularRayDir = specular_scatter(ray.dir, hit.normal);
            // Account for rough reflection
            // Sqauring roughness makes roughness look more perceptually linear: https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/
            specularRayDir = lerp(specularRayDir, diffuseRayDir, hit.material.roughness * hit.material.roughness);
            attenuation = hit.material.specularAlbedo.rgb;
            
            
            ray.dir = specularRayDir;
        }
        else
        {
            ray.dir = diffuseRayDir;
        }

        ray.origin = hit.pos + hit.normal * 0.0001; // offset from intersection for floating point reasons
    }  else {
        //// Do refraction ////

        didRefract = true;

        attenuation = float3(1, 1, 1);
        bool totalInternalReflection = false;
        ray.dir = refract(ray.dir, hit.normal, currentMedium.indexOfRefraction, hitMedium.indexOfRefraction, totalInternalReflection);
        
        if (totalInternalReflection) {
            // float3 diffuseRefractionDir = normalize(hit.normal + roughRefractionVector);
            float3 diffuseRefractionDir = lambertain_scatter(hit.normal, roughReflectionRandom);
            ray.dir = lerp(ray.dir, diffuseRefractionDir, hit.material.roughness * hit.material.roughness);
            ray.origin = hit.pos - hit.normal * 0.0001; // offset from intersection for floating point reasons, but in the opposite direction for refraction
            //attenuation = float3(1000, 1000, 1000);
            
        } else {
            // float3 diffuseRefractionDir = normalize(-hit.normal + roughRefractionVector);
            float3 diffuseRefractionDir = lambertain_scatter(-hit.normal, roughReflectionRandom);
            ray.dir = lerp(ray.dir, diffuseRefractionDir, hit.material.roughness * hit.material.roughness);
            ray.origin = hit.pos - hit.normal * 0.0001; // offset from intersection for floating point reasons, but in the opposite direction for refraction
            
        }
        
    }



    ray.dir = normalize(ray.dir);
    return attenuation;
}

float3 evaluate_material_hit(inout Ray ray, in RayHit hit) {
    float3 attenuation = float3(1, 1, 1);

    // Can't use ternary operator because hlsl
    // https://twitter.com/FreyaHolmer/status/1827278537704780049
    // sigh
    // ParticipatingRayMedium currentMedium = hit.orientation == 1 ? get_top_ray_medium() : hit.material.internalMedium;
    // ParticipatingRayMedium hitMedium = hit.orientation == 1 ? hit.material.internalMedium : get_top_ray_medium();
    // this errors for strange reasons
    ParticipatingRayMedium currentMedium;
    ParticipatingRayMedium hitMedium;


    bool trueHit = true; 

    if (hit.material.internalMedium.priority >= 0) { // if uses interface tracking (must be manifold)
        trueHit = determine_true_medium_hit(hit.material.internalMedium.priority);        
    
    

        if (hit.orientation == 1) {
            currentMedium = get_top_ray_medium();
            hitMedium = hit.material.internalMedium;
            
            add_to_medium_stack(hitMedium);
        } else { 
            if (mediumStackPointer == 0) {
                currentMedium = hit.material.internalMedium;
            } else {
                currentMedium = get_top_ray_medium(); 
            }
            

            pop_from_medium_stack(hit.material.internalMedium.materialID);

            hitMedium = get_top_ray_medium();
        }
    } else {
        if (hit.orientation == 1) {
            currentMedium = get_top_ray_medium();
            hitMedium = hit.material.internalMedium;
        } else {
            currentMedium = hit.material.internalMedium;
            hitMedium = get_top_ray_medium();
        }
        
    }

    // only evaluate bsdf if hit is "real"
    if (trueHit) {
        bool didRefract = false;
        attenuation = material_BRDF(ray, hit, currentMedium, hitMedium, didRefract);

        // I need to refactor this so badly
        // bandaid fix 
        if (hit.orientation > 0 && !didRefract) {
            pop_from_medium_stack(hit.material.internalMedium.materialID);
        }
    } else {
        ray.origin = hit.pos - hit.normal * 0.0001;
        attenuation = float3(1, 1, 1);
    }

    if (currentMedium.materialID != -1) {
        //// Handle absorption //// 
        attenuation *= exp(-currentMedium.absorption * hit.rayT);
    }


    return attenuation;
}

float3 trace_ray_debug_albedo(in Ray ray, in RayHit hit)
{
    // Verify ray hit something (if distance to hit is less than far plane)
    if (hit.rayT < ViewParameters.w) {
        return hit.material.albedo;
    }
    else {
        return sample_sky(ray);
    }
}

float3 trace_ray_debug_normal(in Ray ray, in RayHit hit)
{
    // Verify ray hit something (if distance to hit is less than far plane)
    if (hit.rayT < ViewParameters.w) {
        return (hit.normal + 1) / 2;
    }
    else {
        return sample_sky(ray);
    }
}

float3 trace_ray_debug_triangle_intersections()
{
    if (TriangleTests > TriangleDebugDisplayRange){
        return float3(1,1,1);
    }
    return float3(TriangleTests / (float)TriangleDebugDisplayRange, 0, 0);
}

float3 trace_ray_debug_box_intersections()
{
    if (AABBTests > BoxDebugDisplayRange){
        return float3(1,1,1);
    }
    return float3(AABBTests / (float)BoxDebugDisplayRange, 0, 0);
}

float3 trace_ray_debug_combined_intersections()
{
    if (TriangleTests > TriangleDebugDisplayRange || AABBTests > BoxDebugDisplayRange) {
        return float3(1,1,1);
    }
    return float3(TriangleTests / (float)TriangleDebugDisplayRange, 0, AABBTests / (float)BoxDebugDisplayRange);
}

/*
 * Iterative method documented here: https://www.cs.uaf.edu/2012/spring/cs481/section/0/lecture/02_07_recursion_reflection.html
*/
float3 trace_ray(in Ray ray)
{
    float3 accumulatedColor = float3(0, 0, 0);
    float3 lightAttenuation = float3(1, 1, 1); 
    float accumulatedRoughnes = 0;
    
    for (uint rayInteractions = 0; rayInteractions <= MaxBounces; rayInteractions++)
    {
        if (length(lightAttenuation) < 0.05f)
        {
            break;
        }
        
        RayHit hit = get_ray_intersection(ray);
        
        // Verify ray hit something, if distance to hit is less than far plane
        if (hit.rayT < ViewParameters.w)
        {
            // Scatters ray with diffuse BRDF, or ignores interaction de pending on dielectric priority
            float3 attenuation = evaluate_material_hit(ray, hit); // attenuates and scatters

            
            float3 emissive = hit.material.emissive.rgb * hit.material.emissive.a;
            
            accumulatedColor += emissive * lightAttenuation;
            lightAttenuation *= attenuation; 

            // accumulate roughness accross bounces to do some really bad importance sampling with mipmaps
            accumulatedRoughnes += hit.material.roughness * lightAttenuation;
        }
        else
        {
            #if QUESTIONABLE_IMPORTANCE_SAMPLING
                accumulatedColor += sample_sky(ray, round(DefaultHDRIMipLevel + (accumulatedRoughnes * QUESTIONABLE_IMPORTANCE_SAMPLING_RANGE))) * lightAttenuation; // Emissive
            #else
                accumulatedColor += sample_sky(ray) * lightAttenuation; // Emissive
            #endif
            break;
        }

        /* Increment sobol dimension offset to sample different dimensions per bounce */
        SobolDimensionOffset += BOUNCE_RANDOM_INCREMENT;
    }
    
    return accumulatedColor;
}

float3 trace_ray_debug(in Ray ray)
{
    // Reset debugging data 
    TriangleTests = 0;
    AABBTests = 0;

    // Do ray intersection OUTSIDE of debug switch, or else the compiler inlines and optimizes so agressively that
    // some debug modes won't even perform triangle tests, which messes with performance data.
    RayHit hit;

    
    switch (HalogenDebugMode){
        default:
            return float3(0, 0, 0);
        case 1:
            hit = get_ray_intersection(ray);
            return trace_ray_debug_albedo(ray, hit);
        case 2:
            hit = get_ray_intersection(ray);
            return trace_ray_debug_normal(ray, hit);
        case 3:
            trace_ray(ray);
            return trace_ray_debug_triangle_intersections();
        case 4:
            trace_ray(ray);
            return trace_ray_debug_box_intersections();
        case 5:
            trace_ray(ray);
            return trace_ray_debug_combined_intersections();
    }
}

float2 get_ray_jitter()
{
    float2 jitterRandom = float2_owen_scrambled_sobol(FrameCount, RAY_JITTER_RANDOM_ID, pixelID);
    float jitterX = ((ViewParameters.x * 2) / ScreenParameters.x) * (jitterRandom.x - 0.5f);
    float jitterY = ((ViewParameters.y * 2) / ScreenParameters.y) * (jitterRandom.y - 0.5f);
    
    return float2(jitterX, jitterY);
}

Ray get_ray(float2 uvNDC)
{
    float focalDiscRadius = tan(radians(focalConeAngle)) * ViewParameters.z;
    float3 rayAperturePoint = float3(get_random_point_circle(focalDiscRadius, float2_owen_scrambled_sobol(FrameCount, FOCAL_DISC_RANDOM_ID, pixelID)), 0);
    
    //float clipPlaneModifier = ViewParameters.x / focalPlaneDistance;
    float3 rayScreenPoint = float3(uvNDC.x, uvNDC.y, 1.0f) * ViewParameters.xyz; // Camera space
    rayScreenPoint += float3(get_ray_jitter(), 0.0f);
    
    // I love local space. It's a direction now.
    float3 pointOnFocalPlane = normalize(rayScreenPoint) * focalPlaneDistance; // Camera space
    float3 cameraSpaceDir = normalize(pointOnFocalPlane - rayAperturePoint);
    
    Ray ray;
    ray.origin = (float3)mul(CamLocalToWorldMatrix, float4(rayAperturePoint, 1.0f));
    ray.dir = normalize((float3) mul(CamLocalToWorldMatrix, float4(cameraSpaceDir, 0.0f)));
    return ray;
}

[numthreads(8,8,1)]
void HalogenCompute (uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)ScreenParameters.x || id.y > (uint) ScreenParameters.y)
    {
        return; 
    } 
    
    float2 uv = float2((float)id.x / ScreenParameters.x, (float)id.y / ScreenParameters.y);
    float2 uvNDC = uv * 2.0f - 1.0f;

    // Crutially important 
    // casting to uint makes the calculations wrap instead of clamp
    // eliminating artifacts at high sample counts
    hashState = ((uint)id.x + (uint)id.y * (uint)ScreenParameters.x) * (uint)FrameCount;
    pixelID = u32_hash((uint)id.x + (uint)id.y * (uint)ScreenParameters.x);
    
    float3 RayColor = float3(0.0f, 0.0f, 0.0f);

    [loop]
    for (uint rayID = 0; rayID < SamplesPerPixel; rayID++)
    {
        Ray ray = get_ray(uvNDC);
        
        if (HalogenDebugMode < 1){
            RayColor += trace_ray(ray);
        }else{
            RayColor += trace_ray_debug(ray);
        }
        

        // Debug mesh bounding boxes
        //Ray ray_preInv = ray;
        //ray_preInv.dir = 1 / ray_preInv.dir;
        //for (int k = 0; k < BufferCounts.y; k++)
        //{
        //    if (ray_AABB_test(MeshList[k].boundingCornerA, MeshList[k].boundingCornerB, ray_preInv))
        //    {
        //        RayColor += MaterialList[MeshList[k].materialIndex].albedo * 0.5f;
        //    }
        //}
    }
    RayColor = RayColor / (float)SamplesPerPixel;

    Output[id.xy] = float4(RayColor, 1.0f);
}
